//This is a script that I contributed to one of the indie game Unity3D project that I participated.
//It containts the Attack and Block behaviour function, along with animation blending function and root motion implementation function.
//The Code is isolated and rewritten from the original source code for protfolio use.


Pathfinding.RVO.RVOController agentController;

IEnumerator Attack() // This is the attack behaviour function.
    {
        AttackAnimation = Random.Range(0, 7); //Ramdomly rolling an integer from 0 to 6, which repersents 7 different attack animation
        PlaySwingSFX();
        enemyAnimator.SetInteger("State", AttackAnimation); //Set Animator Controller state to play the previously rolled root motion attack animation
        lookAtPlayer.enabled = false; //Make enemy stop looking at player
        agentController.enabled = false; //Disable navagent
        StartCoroutine(weapon.SetLethal(attackDelay, attackLethalTime), gameObject); //Enable weapon collider
        yield return new WaitForSeconds(attackDelay + attackHazardTime + attackRecovery); //Let the IEnumerator wait until the attack animation is finished
        agentPosUpdateAfterRootMotion(); //Update the navagent's position after the root motion animation is finished.
        agentController.enabled = true; //Re-enable navagent
        enemyAnimator.SetInteger("State", 1); //Set the Animator Controller back to movement state.
        lookAtPlayer.enabled = true; //Make enemy looking at player again
    }

IEnumerator Block() //This is the block behaviour function
    {
        Invincibile = true; //Enemy Does not take damage during blocking
        PlayBlockSFX();
        lookAtPlayer.enabled = false; //Make enemy stop looking at player
        agentController.enabled = false; //Disable navagent
        finalBlockState = Random.Range(0, 3); //Ramdomly rolling an integer from 0 to 2, which repersents 3 different block animation
        enemyAnimator.SetInteger("State", BlockAnimation); //Set Animator Controller state to play the previously rolled root motion block animation
        yield return new Wait(BlockTime); //Let the IEnumerator wait until the block animation is finished
        agentPosUpdateAfterRootMotion(); //Update the navagent's position after the root motion animation is finished.
        lookAtPlayer.enabled = true;// Make enemy looking at player again
        agentController.enabled = true;// Re-enable navagent
        enemyAnimator.SetInteger("State", 1); // Set the Animator Controller back to movement state.
        Invincibile = false;//Make the enemy take damage again
    }
    
void MovementAnimation() //This is the walk animation blend function
    {
        //Get the navagent horizontal movement veolcity and clamp it to a useable range.
        enemyVelX = Mathf.Clamp(agentController.velocity.x, -0.3f, 0.3f);
        enemyVelY = Mathf.Clamp(agentController.velocity.z, -0.3f, 0.6f);
        
        if (!agentController.enabled) //Make sure the movement animation blending stays in idle pose if the navagent is disabled
        {
            enemyVelX = 0f;
            enemyVelY = 0f;
        }
        
        //Set the clamped navagent velocity data to the Animator Controller blending state
        enemyAnimator.SetFloat("VelocityX", enemyVelX);
        enemyAnimator.SetFloat("VelocityY", enemyVelY);
    }
    
void agentPosUpdateAfterRootMotion() // This is a function that implements root motion. It allows the enemy to use treadmill animation for movement and root motion for attack/block
    {
        //In the enemy gameobject hierarchy setup, enemy mesh is a child of the enemy navagent.

        //Snapping the position of the enemy navagent to the enemy mesh position which misaligned with the navagent position after root motion.
        enemyAgentPos.x = enemyMesh.transform.position.x;
        enemyAgentPos.y = transform.position.y; // only snapping 
        enemyAgentPos.z = enemyMesh.transform.position.z;
        transform.position = enemyRootPos;

        Vector3 enemyMeshTransformPos;
        //After the setp above, the navagent is in the correct position.
        //But the enemy mesh position still misaligned with the navagent the enemy navagent due to the mesh is a child
        //Therefore I need to Snap the position of the enemy mesh back to the updated enemy navagent position to make them aligned.
        enemyMeshTransformPos.x = enemyAgentPos.x;
        enemyMeshTransformPos.y = enemyAgentPos.y;
        enemyMeshTransformPos.z = enemyAgentPos.z;

        enemyMesh.transform.position = enemyMeshTransformPos;
    }

    
